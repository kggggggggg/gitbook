{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitbook "},"algorithm/sorting/selection_sort.html":{"url":"algorithm/sorting/selection_sort.html","title":"选择排序 selection sort","keywords":"","body":"选择排序（Selection Sort） 原地排序、不稳定 void selectionSort(int a[], int n) { for (int i = 0; i a[j]) { swap(a[i], a[j]); } } } } 通俗易懂讲解 选择排序.html void selectSort(int a[], int n) { for (int i = 0; i "},"algorithm/sorting/merge_sort.html":{"url":"algorithm/sorting/merge_sort.html","title":"归并排序 merge sort","keywords":"","body":"归并排序（Merge Sort） 不是原地排序算法、稳定(主要看merge函数) void merge(int a[],int l,int r,int mid) { int tmp[r-l+1]; int i = l, j = mid+1, k = 0; while (i =r) return; int mid=(l+r)/2; merge_sort(a,l,mid); merge_sort(a,mid+1,r); merge(a,l,r,mid); } void mergesort(int a[],int l,int r) { merge_sort(a,l,r-1); } merge算法使用哨兵优化 void merge(int a[],int l,int r,int mid) { int left[mid-l+2]; //左侧长度是midl-l+1 再加一个哨兵 int right[r-mid+1];//右侧长度是r-(mid+1)+1 再加一个哨兵 left[mid-l+1] = INT_MAX; right[r-mid] = INT_MAX; for (int i = l,k = 0; i "},"algorithm/sorting/quick_sort.html":{"url":"algorithm/sorting/quick_sort.html","title":"快速排序算法 quicksort","keywords":"","body":"快速排序算法（Quicksort） 原地排序、不稳定 方式一 因为固定pivot是取得左边的值，所以while时，要先从右边找； void quickSort(int a[], int head, int tail) { int low = head; int high = tail; int pivot = a[low]; while (low= a[low]) low++; a[high]=a[low]; } a[low] = pivot; if(low>head+1) quickSort(a,head,low-1); if(high 方式二 1、因为先从右边找。 2、而最终因为low == high。 3、所以现在low和high的值小于a[head]。 4、判断条件 a[head] >= a[low] 导致a[head]位置不会变 也就是分割点位置不变，始终在head位置 5、所以最后需要再进行一次交换 swap(a[low], a[head]); void quickSort(vector& a, int head, int tail) { if (head >= tail) { return; } int low = head; int high = tail; while (low= a[low]) low++; swap(a[low], a[high]); } swap(a[low], a[head]); quickSort(a,head,low-1); quickSort(a,high+1,tail); } 方法三 int Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low = pivot) { --high; } A[low] = A[high]; while (low "},"algorithm/sorting/bubble_sort.html":{"url":"algorithm/sorting/bubble_sort.html","title":"冒泡排序 bubble sort","keywords":"","body":"冒泡排序（Bubble Sort） 原地排序、稳定 void bubbleSort(int a[], int n) { for(int i = n - 1; i > 0; i--) for(int j = 0; j a[j+1]) swap(a[j], a[j+1]); } "},"algorithm/sorting/insertion_sort.html":{"url":"algorithm/sorting/insertion_sort.html","title":"插入排序 insertion sort","keywords":"","body":"插入排序（Insertion Sort） 原地排序、稳定 c++插入排序算法.html void InsertSort(int a[], int n) { for (int i = 1; i = 0 && a[j] > v) { a[j+1] = a[j]; j--; } a[j+1] = v; } } void insertionSort(int a[], int n) { if (n = 0; --j) { if (a[j] > value) { a[j+1] = a[j]; } else { break; } } a[j+1] = value; // 插入数据 } } "},"algorithm/sorting.html":{"url":"algorithm/sorting.html","title":"排序算法 sorting algorithm","keywords":"","body":"🙉 排序算法(Sorting Algorithm) 冒泡排序(Bubble Sort) 选择排序(Selection Sort) 插入排序(Insertion Sort) 归并排序(Merge Sort) 快速排序(Quick Sort) 堆排序(Heap Sort) 桶排序(Bucket sort) 计数排序(Counting Sort) 基数排序(Radix Sort) 排序算法大全 "},"flutter/状态管理/00前言.html":{"url":"flutter/状态管理/00前言.html","title":"flutter的状态管理","keywords":"","body":"Flutter的状态管理 声名式编程框架 声名式编程框架（Declarative Programming Framework）是一种编程范式，其中程序的逻辑和行为是通过声明式的方式来描述，而不是通过编写详细的控制流程和状态变化的命令式代码。 在声名式编程框架中，开发人员主要关注程序的\"是什么\"而不是\"如何\"，即描述程序的目标和所需的结果，而不是详细说明如何达到这些结果。通过声明式的方式，开发人员描述程序的期望状态和逻辑，由框架或运行时环境负责处理具体的执行流程。 声名式编程框架的优点包括： 简洁性：通过声明式的方式，可以更清晰、简洁地表达程序的意图和目标，减少冗余和重复的代码。 可读性：声名式代码更易于阅读和理解，因为它强调程序的目标和意图，而不是详细的执行流程。 可维护性：声名式代码通常更易于维护，因为它减少了复杂的控制流程和状态变化的代码，使代码更模块化和可组合。 可扩展性：通过将程序的逻辑和行为以声明式的方式描述，声名式编程框架提供了更灵活和可扩展的方式来修改和扩展程序。 在Flutter中，开发人员使用声明式语法来描述数据与界面的关联关系。通过在组件中使用插值表达式、属性传递和回调函数，开发人员可以将数据动态地绑定到界面上。当数据发生变化时，Flutter会自动重新构建相关的组件以反映最新的数据。 总之，声名式编程框架是一种通过声明式的方式描述程序的目标和结果的编程范式。它提供了简洁、可读、可维护和可扩展的代码编写方式，使开发人员能够更聚焦于程序的逻辑而不是具体的控制流程。 声名式框架使用声明式语法来描述数据与界面的关系。当数据发生变化时，Flutter会自动重新构建相关的组件以反映最新的数据。 Q1 什么是状态 Flutter中的状态是指应用程序中的数据，可以是用户输入、网络请求结果、应用程序配置等等。 比如当前使用的主题，语言 Q2 state和状态是什么关系 Flutter 应用是 声明式 的，这也就意味着 Flutter 构建的用户界面就是应用的当前状态。 Q3为什么需要状态管理 状态管理的目的是确保应用程序在不同组件之间共享和同步状态的变化。 Q4如果没有状态管理 如果在Flutter应用程序中不使用适当的状态管理解决方案，可能会导致数据共享困难、组件之间通信问题以及难以追踪和管理状态变化。这些问题可能导致代码冗余、维护困难和潜在的错误。因此，选择适当的状态管理解决方案可以提高代码的可维护性和可扩展性，以及改善应用程序的用户体验。 比如购物车功能，如果通过一层一层的回调方法来进行数据传递，将会有数据共享困难、数据流变得模糊、代码冗余等问题。 Q4状态管理包 Provider Redux BLoC GetX Q5EvenBus Flutter EventBus（事件总线）并不是严格意义上的状态管理解决方案，而是一种用于在组件之间进行事件通信的机制。它可以作为一种辅助工具来处理组件之间的解耦和通信需求，但与常见的状态管理解决方案（如Provider、GetX、BLoC等）相比，它更专注于事件的发布和订阅。 事件总线模式是一种发布/订阅模式，通过事件的发布和订阅，组件可以在不直接依赖彼此的情况下进行通信。通过事件总线，一个组件可以发送事件，而其他组件可以订阅并接收这些事件，并做出相应的响应。 在Flutter中，可以使用第三方库或自定义实现的事件总线来实现这种通信模式。例如，常见的Flutter事件总线库包括event_bus和flutter_bloc等。 尽管Flutter EventBus可以在一定程度上解决组件之间的通信需求，但它并没有提供集中式的状态管理和状态变更的机制。状态管理解决方案通常提供一种管理应用程序状态的机制，可以集中处理状态的变化、跟踪状态的变化历史，并提供一种响应式的方式来更新组件的UI。 综上所述，虽然Flutter EventBus（事件总线）可以辅助组件之间的通信，但它不是严格的状态管理解决方案。在大多数情况下，使用专门的状态管理库可以更好地管理和响应应用程序的状态变化。 状态 (State) 管理介绍 "},"flutter/状态管理/01Provider/01InheritedWidget.html":{"url":"flutter/状态管理/01Provider/01InheritedWidget.html","title":"01InheritedWidget","keywords":"","body":"1. InheritedWidget的使用 首先创建一个ShareDataWidget继承自InheritedWidget class ShareDataWidget extends InheritedWidget { const ShareDataWidget({ Key? key, required this.data, required Widget child, }) : super(key: key, child: child); final int data; //需要在子树中共享的数据，保存点击次数 //定义一个便捷方法，方便子树中的widget获取共享数据 static ShareDataWidget? of(BuildContext context) { //return context.dependOnInheritedWidgetOfExactType(); return context .getElementForInheritedWidgetOfExactType() ?.widget as ShareDataWidget; } //该回调决定当data发生变化时，是否通知子树中依赖data的Widget @override bool updateShouldNotify(ShareDataWidget old) { return old.data != data; } } 实现一个子组件_TestWidget，在其build方法中引用ShareDataWidget中的数据。同时，在其didChangeDependencies() 回调中打印日志 class _TestWidget extends StatefulWidget { @override __TestWidgetState createState() => __TestWidgetState(); } class __TestWidgetState extends State { @override Widget build(BuildContext context) { //使用InheritedWidget中的共享数据 //stylebegin {background-color: #FFFF0050;} return Text(ShareDataWidget.of(context)!.data.toString()); //styleend } @override void didChangeDependencies() { super.didChangeDependencies(); //父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。 //如果build中没有依赖InheritedWidget，则此回调不会被调用。 print(\"Dependencies change\"); } } InheritedWidgetTestRoute创建一个按钮，每点击一次，就将ShareDataWidget的值自增 class InheritedWidgetTestRoute extends StatefulWidget { ... } class _InheritedWidgetTestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return Center( //stylebegin {background-color: #FFFF0050;} child: ShareDataWidget( //使用ShareDataWidget //styleend data: count, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Padding( padding: const EdgeInsets.only(bottom: 20.0), child: _TestWidget(), //子widget中依赖ShareDataWidget ), ElevatedButton( child: const Text(\"Increment\"), //每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新 onPressed: () => setState(() => ++count), ) ], ), ), ); } } 2. InheritedWidget的原理 2.1 _inheritedWidgets abstract class Element extends DiagnosticableTree implements BuildContext Element? _parent; PersistentHashMap? _inheritedWidgets; Set? _dependencies; bool _hadUnsatisfiedDependencies = false; /// Add this element to the tree in the given slot of the given parent. @mustCallSuper void mount(Element? parent, Object? newSlot) { ... _updateInheritance(); ... } /// Transition from the \"inactive\" to the \"active\" lifecycle state. @mustCallSuper void activate() { ... _updateInheritance(); ... } void _updateInheritance() { ... _inheritedWidgets = _parent?._inheritedWidgets; } } class InheritedElement extends ProxyElement{ final Map _dependents = HashMap(); @override void _updateInheritance() { final PersistentHashMap incomingWidgets = _parent?._inheritedWidgets ?? const PersistentHashMap.empty(); _inheritedWidgets = incomingWidgets.put(widget.runtimeType, this); } } _inheritedWidgets void _updateInheritance()主要负责 _inheritedWidgets赋值 调用时机: mount和activate方法。 对于普通的Element，_inheritedWidgets只是从_parent读取。 InheritedElement中，_inheritedWidgets从_parent读取为空的话，会创建一个。并存储。key为widget.runtimeType,value为当前的InheritedElement。 _inheritedWidgets 方便观察者快速获取到对应的InheritedElement，从而获取数据。 _dependents InheritedElement中的_dependents，存储了观察者 需要更新时，遍历观察者，通知观察者更新 _dependencies Set? _dependencies;观察者存储了他所依赖的 InheritedElement。 class _UbiquitousInheritedElement extends InheritedElement中有用到。 去掉了，_dependents。这样保证创建过程更快速。但是更新会变慢。 可以看这里 2.2 注册依赖关系 T? dependOnInheritedWidgetOfExactType({ Object? aspect }); abstract class Element extends DiagnosticableTree implements BuildContext @override T? dependOnInheritedWidgetOfExactType({Object? aspect}) { assert(_debugCheckStateIsActiveForAncestorLookup()); // 1. 查找InheritedElement类型的祖先节点 final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; if (ancestor != null) { return dependOnInheritedElement(ancestor, aspect: aspect) as T; } _hadUnsatisfiedDependencies = true; return null; } @override InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) { // 2. 创建_dependencies用来存储当前element依赖了哪些InheritedElement _dependencies ??= HashSet(); _dependencies!.add(ancestor); // ancestor.updateDependencies(this, aspect); //添加到InheritedElement中。 // 4. 返回 ancestor（InheritedWidget类型的祖先节点） return ancestor.widget as InheritedWidget; } } class InheritedElement extends ProxyElement{ final Map _dependents = HashMap(); @protected void updateDependencies(Element dependent, Object? aspect) { setDependencies(dependent, null); } @protected void setDependencies(Element dependent, Object? value) { // 3. InheritedElement中的_dependents，用来存储对应的观察者。 _dependents[dependent] = value; //添加到对应的map种。 这里value为空。 } } 依赖关系： Element（观察者）中的_dependencies存储了使用到的InheritedElement InheritedElement的_dependents存储了注册的观察者Element 2.3 更新监听 class InheritedElement extends ProxyElement{ //重写了updated方法 @override void updated(InheritedWidget oldWidget) { if ((widget as InheritedWidget).updateShouldNotify(oldWidget)) { super.updated(oldWidget); // super中调用了notifyClients } } //遍历每一个监听者 @override void notifyClients(InheritedWidget oldWidget) { for (final Element dependent in _dependents.keys) { notifyDependent(oldWidget, dependent); } } //调用坚挺着didChangeDependencies方法 @protected void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) { dependent.didChangeDependencies(); } } abstract class Element extends DiagnosticableTree implements BuildContext { //标记为_dirty @mustCallSuper void didChangeDependencies() { markNeedsBuild(); } void markNeedsBuild() { if (dirty) { return; } _dirty = true; owner!.scheduleBuildFor(this); } } class BuildOwner { void scheduleBuildFor(Element element) { _dirtyElements.add(element); //添加到dirtyElements列表中。 element._inDirtyList = true; } } 3.总结 _inheritedWidgets存储InheritedElement，方便观察者快速找到对应的InheritedElement _dependents 存储观察者，InheritedElement通过遍历通知观察者更新 本身所有的Element都维护一个map。（可以认为是一个全局的，因为会先从_parent获取） PersistentHashMap? _inheritedWidgets; element类型为key。 每一个InheritedElement实例对象都会维护一个map。 final Map _dependents = HashMap(); 以调用者的element为key，value可以为空。 当创建一个InheritedElement，调用mount时就会加入到_inheritedWidgets中。 查找的时候通过类型直接在map中找出。 调用dependOnInheritedWidgetOfExactType获取值的时候 _inheritedWidgets中找到对应的InheritedElement 将当前对象存储到InheritedElement对应的_dependents字典中 返回对应的InheritedElement 需要更新，调用InheritedWidget的update的时候 _dependents.keys获取存储的element，并调用其didChangeDependencies方法。 didChangeDependencies --> markNeedsBuild --> _dirty = true; 4. 应该在didChangeDependencies()中做什么？ 一般来说，子 widget 很少会重写此方法，因为在依赖改变后 Flutter 框架也都会调用build()方法重新构建组件树。但是，如果你需要在依赖改变后执行一些昂贵的操作，比如网络请求，这时最好的方式就是在此方法中执行，这样可以避免每次build()都执行这些昂贵操作。 5. 其他 _UbiquitousInheritedElement /// An [InheritedElement] that has hundreds of dependencies but will /// infrequently change. This provides a performance tradeoff where building /// the [Widget]s is faster but performing updates is slower. /// /// | | _UbiquitousInheritedElement | InheritedElement | /// |---------------------|------------------------------|------------------| /// | insert (best case) | O(1) | O(1) | /// | insert (worst case) | O(1) | O(n) | /// | search (best case) | O(n) | O(1) | /// | search (worst case) | O(n) | O(n) | /// /// Insert happens when building the [Widget] tree, search happens when updating /// [Widget]s. class _UbiquitousInheritedElement extends InheritedElement { /// Creates an element that uses the given widget as its configuration. _UbiquitousInheritedElement(super.widget); @override void setDependencies(Element dependent, Object? value) { // This is where the cost of [InheritedElement] is incurred during build // time of the widget tree. Omitting this bookkeeping is where the // performance savings come from. assert(value == null); } @override Object? getDependencies(Element dependent) { return null; } @override void notifyClients(InheritedWidget oldWidget) { _recurseChildren(this, (Element element) { if (element.doesDependOnInheritedElement(this)) { notifyDependent(oldWidget, element); } }); } static void _recurseChildren(Element element, ElementVisitor visitor) { element.visitChildren((Element child) { _recurseChildren(child, visitor); }); visitor(element); } } 参考 【老孟Flutter】源码分析系列之InheritedWidget 一文搞懂InheritedWidget局部刷新机制 flutter防止widget rebuild终极解决办法 "},"flutter/状态管理/01Provider/02Provider基本使用.html":{"url":"flutter/状态管理/01Provider/02Provider基本使用.html","title":"02Provider基本使用","keywords":"","body":"Provider优势 我们为什么要用Provider而不是直接使用InheritedWidget，我们看下官方介绍 简化的资源分配与处置 懒加载 创建新类时减少大量的模板代码 支持 DevTools 更通用的调用 InheritedWidget 的方式（参考 Provider.of/Consumer/Selector） 提升类的可扩展性，整体的监听架构时间复杂度以指数级增长（如 ChangeNotifier， 其复杂度为 O(N)） 常见的几种Provider Provider Provider是最基本的Provider组件 // This class is what Provider will work with. // It will _provide_ an instance of the class to any widget // in the tree that cares about it. class Person { Person({this.name, this.age}); final String name; final int age; } // Here, we are running an app as you'd expect with any Flutter app // But, we're also wrapping `MyApp` in a widget called 'Provider' // Importantly, `Provider` is itself a widget, so it can live in the widget tree. // This class uses a property called `create` to make an instance of `Person` // whenever it's needed by a widget in the tree. // The object returned by the function passed to `create` is what the rest of our app // has access to. void main() { runApp( Provider( create: (_) => Person(name: \"Yohan\", age: 25), child: MyApp(), ), ); } // Just a plain ol' StatelessWidget class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return const MaterialApp( home: MyHomePage(), ); } } // Again, just a stateless widget class MyHomePage extends StatelessWidget { const MyHomePage({Key key}) : super(key: key); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Provider Class'), ), body: Center( child: Text( // this string is where we use Provider to fetch the instance // of `Person` created above in the `create` property ''' Hi ${Provider.of(context).name}! You are ${Provider.of(context).age} years old''', ), ), ); } } ListenableProvider ChangeNotifierProvider继承自ListenableProvider且对应的ChangeNotifier继承自listenable；算是ListenableProvider的子类；ValueNotifier继承自ChangeNotifier也与ChangeNotifierProvider相似； 使用ChangeNotifierProvider和ValueListenableProvider绑定实体类时需要注意分别继承对应的ChangeNotifier和ValueNotifier； 所以ChangeNotifierProvider只是对ListenableProvider的进一步封装。从ValueNotifier到ChangeNotifier的监听。 ChangeNotifierProvider 它跟Provider组件不同，ChangeNotifierProvider会监听模型对象的变化，而且当数据改变时，它也会重建Consumer（消费者） class Person with ChangeNotifier { Person({this.name, this.age}); final String name; int age; void increaseAge() { this.age++; notifyListeners(); } } // here, you can see that the [ChangeNotifierProvider] // is \"wired up\" exactly like the vanilla [Provider] void main() { runApp( ChangeNotifierProvider( create: (_) => Person(name: \"Yohan\", age: 25), child: MyApp(), ), ); } class MyHomePage extends StatelessWidget { const MyHomePage({Key key}) : super(key: key); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Provider Class'), ), body: Center( child: Text( // reading this data is exactly like it was in // the previous lesson ''' Hi ${Provider.of(context).name;}! You are ${Provider.of(context).age} years old''', ), ), floatingActionButton: FloatingActionButton( // this is where there's a difference. // when the FAB is tapped, it will call `Person.icreaseAge()` on the // person instance that was created by provider. onPressed: () => Provider.of(context, listen: false).increaseAge(), ), ); } } ValueListenableProvider FutureProvider 用于提供在组件树中准备好使用其值时可能尚未准备好的值，主要是确保空值不会传递给任何子组件，而且FutureProvider有一个初始值，子组件可以使用该Future值并告诉子组件使用新的值来进行重建。 class Person { Person({this.name, this.age}); final String name; int age; } class Home { final String city = \"Portland\"; Future get fetchAddress { final address = Future.delayed(Duration(seconds: 2), () { return '1234 North Commercial Ave.'; }); return address; } } void main() { runApp( Provider( create: (_) => Person(name: 'Yohan', age: 25), child: FutureProvider( create: (context) => Home().fetchAddress, initialData: \"fetching address...\", child: MyApp(), ), ), ); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return const MaterialApp( home: MyHomePage(), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({Key key}) : super(key: key); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"Future Provider\"), ), body: Padding( padding: const EdgeInsets.all(8.0), child: Center( child: Consumer( builder: (context, Person person, child) { return Column( children: [ Text(\"User profile:\"), Text(\"name: ${person.name}\"), Text(\"age: ${person.age}\"), Consumer(builder: (context, String address, child) { return Text(\"address: $address\"); }), ], ); }, ), ), ), ); } } 注意： FutureProvider只会重建一次 默认显示初始值 然后显示Future值 最后不会再次重建 StreamProvider StreamProvider提供流值，是围绕StreamBuilder，所提供的值会在传入的时候替换掉新值。和FutureProvider一样，主要的区别在于值会根据多次触发重新构建UI。 class Person { Person({this.name, this.initialAge}); final String name; final int initialAge; Stream get age async* { var i = initialAge; while (i ( create: (_) => Person(name: 'Yohan', initialAge: 25).age, initialData: 25.toString(), catchError: (_, error) => error.toString(), child: MyApp(), ), ); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return const MaterialApp( home: MyHomePage(), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({Key key}) : super(key: key); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"Future Provider\"), ), body: Padding( padding: const EdgeInsets.all(8.0), child: Center( child: Consumer( builder: (context, String age, child) { return Column( children: [ Text(\"Watch Yohan Age...\"), Text(\"name: Yohan\"), Text(\"age: $age\"), ], ); }, ), ), ), ); } } ProxyProvider ProxyProviders有几种 ProxyProvider ChangeNotifierProxyProvider ListenableProxyProvider 当我们有多个模型的时候，会有模型依赖另一个模型的情况，在这种情况下，我们可以使用ProxyProvider从另一个提供者获取值，然后将其注入到另一个提供者中。 testWidgets('ListenableProxyProvider2', (tester) async { await tester.pumpWidget( MultiProvider( providers: [ Provider.value(value: a), Provider.value(value: b), Provider.value(value: c), Provider.value(value: d), Provider.value(value: e), Provider.value(value: f), ProxyProvider2( create: (_) => const Combined(), update: (context, a, b, previous) => Combined(context, previous, a, b), ) ], child: mockConsumer, ), ); 当a,b有变化时，都会通知到ListenableProxyProvider2。 ChangeNotifierProxyProvider 和ProxyProvider原理一样，唯一的区别在于它构建和同步ChangeNotifier的ChangeNotifierProvider，当提供者数据变化时，将会重构UI。 import 'dart:collection'; import 'package:flutter/foundation.dart'; import 'package:flutter/material.dart'; class Person with ChangeNotifier { Person({this.name, this.age}); final String name; int age; void increaseAge() { this.age++; notifyListeners(); } } class Job with ChangeNotifier { Job( this.person, { this.career, }); final Person person; String career; String get title { if (person.age >= 28) return 'Dr. ${person.name}, $career PhD'; return '${person.name}, Student'; } } void main() { runApp( MultiProvider( providers: [ ChangeNotifierProvider(create: (_) => Person(name: 'Yohan', age: 25)), ChangeNotifierProxyProvider( //当person变化，也会通知到Job。 create: (BuildContext context) => Job(Provider.of(context, listen: false)), update: (BuildContext context, Person person, Job job) => Job(person, career: 'Vet'), ), ], child: MyApp(), ), ); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return const MaterialApp( home: MyHomePage(), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({Key key}) : super(key: key); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Provider Class'), ), body: Align( alignment: Alignment.center, child: Container( padding: EdgeInsets.all(20.0), decoration: BoxDecoration( border: Border.all(), borderRadius: BorderRadius.circular(5.0), ), child: Column( mainAxisSize: MainAxisSize.min, children: [ Text( 'Hi, may name is ${context.select((Job j) => j.person.name)}', style: Theme.of(context).textTheme.headline6, ), Text('Age: ${context.select((Job j) => j.person.age)}'), Text(context.watch().title), ], ), ), ), floatingActionButton: FloatingActionButton( onPressed: () => Provider.of(context, listen: false).increaseAge(), ), ); } } ListenableProxyProvider ListenableProxyProvider是ListenableProvider的一个变体，但是在使用上和ChangeNotifierProvider效果惊人的一致 MultiProvider 继承自Nested class MultiProvider extends Nested { MultiProvider({ Key? key, required List providers, Widget? child, TransitionBuilder? builder, }) : super( key: key, children: providers, child: builder != null ? Builder( builder: (context) => builder(context, child), ) : child, ); } test(){ MultiProvider( providers: [ PA, PB, PC ), child: XXX(), } PA的child是PB。PB的child是PC。PC的child是XXX。 .value constructors 之前使用Provider时候，都是使用create()进行创建一个新值，倘若我们想要观测一个已经存在的实例化对象时候，就不可以这样了。 这时候需要使用Provider.value的方式或者其它类的.value,例如ChangeNotifierProvider.value 该方法也可以将内部的某个值提供给其子类 总结：在 Provider 中，.value 方法用于手动提供一个固定的数值作为数据源，而不使用 Provider 类自动创建或管理数据源。 总结 Provider为我们提供了非常多的提供者。但我们比较常用的是ChangeNotifierProvider、MultiProvider、ChangeNotifierProxyProvider，关于其他的提供者可根据自己的实际应用场景来。 四种消费者 Provider.of Provider.of(context).increment(); static T of(BuildContext context, {bool listen = true}) { assert( context.owner!.debugBuilding || //widget正在构建 listen == false || //widget如果不是构建过程，说明是类似点击按钮取值，不用listen。 debugIsInInheritedProviderUpdate, ''' Tried to listen to a value exposed with provider, from outside of the widget tree. This is likely caused by an event handler (like a button's onPressed) that called Provider.of without passing `listen: false`. To fix, write: Provider.of(context, listen: false); It is unsupported because may pointlessly rebuild the widget associated to the event handler, when the widget tree doesn't care about the value. The context used was: $context ''', ); ... child: ElevatedButton( onPressed: (){ Provider.of(context).increment(); //报错 Provider.of(context, listen: false).increment(); }, child: Text(\"点击加1\"), ), Consumer Consumber只是在Widget中调用了Prvoider.of，并将其构造实现委托给了构造器 class Consumer extends SingleChildStatelessWidget { Consumer({ Key? key, required this.builder, Widget? child, }) : super(key: key, child: child); final Widget Function( BuildContext context, T value, Widget? child, ) builder; //数据更新的时候会调用buildWithChild。 child保存在Consumer属性中。不会更新。 @override Widget buildWithChild(BuildContext context, Widget? child) { return builder( context, Provider.of(context), child, ); } } Selector 选择器与消费者相似，但对何时调用小部件build方法提供了一些精细的控制。简而言之，selector是一个消费者，它允许您从您关心的模型中准确定义哪些属性。 class Person with ChangeNotifier { Person({this.name, this.age}); final String name; int age; void increaseAge() { this.age++; notifyListeners(); } } void main() { runApp( ChangeNotifierProvider( create: (_) => Person(name: \"Yohan\", age: 25), child: MyApp(), ), ); } class MyHomePage extends StatelessWidget { const MyHomePage({Key key}) : super(key: key); @override Widget build(BuildContext context) { return Selector( selector: (BuildContext context, Person person) => person.name, builder: (context, String name, child) { return Scaffold( appBar: AppBar( title: Text(\"${name} -- ${Provider.of(context).age} yrs old\"), ), body: child, ); }, child: Center( child: Text('Hi this represents a huge widget! Like a scrollview with 500 children!'), ), ); } } Context Extension InheritedContext是Provider内置扩展了BuildContext，它不保存了组件在树中自己位置的引用，我们在上面的案例中见到Provider.of(context，listen: false)，其实这个of方法就是使用Flutter查找树并找到Provider子类型为CountNotifier1而已。 BuildContext.read: BuildContext.read()可以替换掉Provider.of(context，listen: false)，它会找到CountNotifier1并返回它。 BuildContext.watch: BuildContext.watch()可以替换掉Provider.of(context，listen: false)，看起来和read没有什么不同，但是使用watch你就不需要在使用Consumer。 BuildContext.select: BuildContext.select()可以替换掉Provider.of(context，listen: false)，看起来和watch也没有什么不同，但是使用select你就不需要在使用Selector。 layz lazy为true create在获取值的时候才会执行 防止重复刷新 参考 README proxy-provider flutter_by_example_static 使用 Nested 处理 flutter 嵌套过深 "},"flutter/状态管理/01Provider/03Provider源码解析.html":{"url":"flutter/状态管理/01Provider/03Provider源码解析.html","title":"03Provider源码解析","keywords":"","body":"Provider 从最基础的InheritedProvider开始分析。了解了这一部分，其他的只是再起基础上进行了内容丰富。 1. InheritedProvider 1.1 class InheritedProvider 精简代码之后如下。重点注释可以查看代码。 class InheritedProvider extends SingleChildStatelessWidget { // 1. 构造方法 InheritedProvider({ Key? key, Create? create, // 用来创建Provider持有的对象 T Function(BuildContext context, T? value)? update, // 当前Provider更新时触发。 // Provider更新时,数据不一定变化，判断是否需要通知观察者更新。 UpdateShouldNotify? updateShouldNotify, // 第一次获取数据的时候被调用。返回一个取消订阅的监听 StartListening? startListening, Dispose? dispose, //从widget tree中移除的时候调用 this.builder, //构造语法糖 bool? lazy, // create方法是否懒加载 Widget? child, }) : _lazy = lazy, //将上面的初始化参数传递给代理。这样可以通过实现不同的代理对象实现不同的功能。 _delegate = _CreateInheritedProvider( create: create, update: update, updateShouldNotify: updateShouldNotify, startListening: startListening, dispose: dispose, ), super(key: key, child: child); final _Delegate _delegate; final bool? _lazy; final TransitionBuilder? builder; @override Widget buildWithChild(BuildContext context, Widget? child) { //根布局是 _InheritedProviderScope。 return _InheritedProviderScope( owner: this, child: builder != null ? Builder( builder: (context) => builder!(context, child), ) : child!, ); } } 1.2 class _InheritedProviderScope 其中部分操作会让delegate来实现。功能更加灵活。 class _InheritedProviderScope extends InheritedWidget { const _InheritedProviderScope({ required this.owner, required this.debugType, required Widget child, }) : assert(null is T), super(child: child); final InheritedProvider owner; //对应的InheritedProvider。其实是父widget //重写此方法，是否通知更新使用InheritedProvider传入的updateShouldNotify @override bool updateShouldNotify(InheritedWidget oldWidget) { return false; } //创建element @override _InheritedProviderScopeElement createElement() { return _InheritedProviderScopeElement(this); } } class _InheritedProviderScopeElement extends InheritedElement implements InheritedContext { _InheritedProviderScopeElement(_InheritedProviderScope widget) : super(widget); static int _nextProviderId = 0; bool _shouldNotifyDependents = false; bool _debugInheritLocked = false; bool _isNotifyDependentsEnabled = true; bool _updatedShouldNotify = false; bool _isBuildFromExternalSources = false; late final _DelegateState> _delegateState = widget.owner._delegate.createState()..element = this; @override InheritedElement? getElementForInheritedWidgetOfExactType() { InheritedElement? inheritedElement; // 尝试在父布局中获取相同类型的Provider。 visitAncestorElements((parent) { inheritedElement = parent.getElementForInheritedWidgetOfExactType(); return false; }); return inheritedElement; } //添加观察者 @override void updateDependencies(Element dependent, Object? aspect) { final dependencies = getDependencies(dependent); //可以查看 SelectContext //typedef _SelectorAspect = bool Function(T value); //aspect是一个方法。则注册成为一个Selector类型的观察者。 //通过SelectContext中的context.select 方式 if (aspect is _SelectorAspect) { //selectorDependency相当于是一个方法的容器。 final selectorDependency = (dependencies ?? _Dependency()) as _Dependency; selectorDependency.selectors.add(aspect); //存储观察者对应的值是selectorDependency setDependencies(dependent, selectorDependency); } else { //存储观察者对应的值是Object。 setDependencies(dependent, const Object()); } } //通知依赖的观察者执行更新 @override void notifyDependent(InheritedWidget oldWidget, Element dependent) { final dependencies = getDependencies(dependent); var shouldNotify = false; if (dependencies != null) { //可以查看 SelectContext //_Dependency类型，执行存储的select方法。 if (dependencies is _Dependency) {...} if (shouldNotify) { //观察者更新。 dependent.didChangeDependencies(); } } @override void update(_InheritedProviderScope newWidget) { _isBuildFromExternalSources = true; //通知delegate执行 willUpdateDelegate _updatedShouldNotify = _delegateState.willUpdateDelegate(newWidget.owner._delegate); super.update(newWidget); _updatedShouldNotify = false; } //因为重写了 bool updateShouldNotify(InheritedWidget oldWidget) 逻辑。 //所以这里重写updated。使用_updatedShouldNotify判断是否通知更新 @override void updated(InheritedWidget oldWidget) { super.updated(oldWidget); if (_updatedShouldNotify) { notifyClients(oldWidget); } } @override Widget build() { if (widget.owner._lazy == false) { //非懒加载，执行一次getter方法。 value; } //通知代理执行 build 方法。 _delegateState.build( isBuildFromExternalSources: _isBuildFromExternalSources, ); _isBuildFromExternalSources = false; //代理的build方法可以对_shouldNotifyDependents进行赋值，决定是否要调用notifyClients if (_shouldNotifyDependents) { _shouldNotifyDependents = false; notifyClients(widget); } return super.build(); } @override void unmount() { //调用代理的dispose _delegateState.dispose(); super.unmount(); } //获取value的方法，交给代理执行。 @override T get value => _delegateState.value; } 1.3. _Delegate _DelegateState 1.3.1 协议 @immutable abstract class _Delegate { _DelegateState> createState(); void debugFillProperties(DiagnosticPropertiesBuilder properties) {} } abstract class _DelegateState> { _InheritedProviderScopeElement? element; //用来获取provider持有的值 T get value; //其实就是 _Delegate D get delegate => element!.widget.owner._delegate as D; //是否有值，对于_CreateInheritedProvider来说是执行了create方法，对于_ValueInheritedProvider始终是true。 bool get hasValue; bool debugSetInheritedLock(bool value) { return element!._debugSetInheritedLock(value); } bool willUpdateDelegate(D newDelegate) => false; //_InheritedProviderScopeElement 执行 unmount方法。 void dispose() {} void debugFillProperties(DiagnosticPropertiesBuilder properties) {} //_InheritedProviderScopeElement 执行 build方法 void build({required bool isBuildFromExternalSources}) {} } 1.3.2 _CreateInheritedProvider class _CreateInheritedProvider extends _Delegate { @override _CreateInheritedProviderState createState() => _CreateInheritedProviderState(); } class _CreateInheritedProviderState extends _DelegateState> { ////_InheritedProviderScopeElement的 取值操作 调用这里。 @override T get value { bool? _debugPreviousIsInInheritedProviderCreate; bool? _debugPreviousIsInInheritedProviderUpdate; //_didInitValue 表示是否初始化完成Value。其实就是执行一次 get value if (!_didInitValue) { _didInitValue = true; if (delegate.create != null) { //执行create方法，创建值 _value = delegate.create!(element!); } if (delegate.update != null) { //执行update方法，更新值 _value = delegate.update!(element!, _value); } } //返回值 return _value as T; } //_InheritedProviderScopeElement的dispose方法调用这里。 @override void dispose() { super.dispose(); _removeListener?.call(); if (_didInitValue) { //执行dispose方法 delegate.dispose?.call(element!, _value as T); } } //_InheritedProviderScopeElement的build方法调用这里。 @override void build({required bool isBuildFromExternalSources}) { var shouldNotify = false; if (isBuildFromExternalSources && _didInitValue && delegate.update != null) { final previousValue = _value; //通过delegate._updateShouldNotify或者前后值是否相等 _value = delegate.update!(element!, _value as T); //update实现的前提下 if (delegate._updateShouldNotify != null) { shouldNotify = delegate._updateShouldNotify!( previousValue as T, _value as T, ); } else { shouldNotify = _value != previousValue; } } if (shouldNotify) { //这里等于true。_InheritedProviderScopeElement的build种会执行 notifyClients(widget); element!._shouldNotifyDependents = true; } } } 1.4 总结 其他类型的Provider都是在这个基础上实现的。了解了InheritedProvider其他的就很简单了。 2. Provider Provider为InheritedProvider提供了.of方法。便于快速取值 class Provider extends InheritedProvider { //提供 .of 快速获取value。 static T of(BuildContext context, {bool listen = true}) { final inheritedElement = _inheritedElementOf(context); if (listen) { context.dependOnInheritedWidgetOfExactType>(); } final value = inheritedElement?.value; return value as T; } static _InheritedProviderScopeElement? _inheritedElementOf( BuildContext context, ) { final inheritedElement = context.getElementForInheritedWidgetOfExactType>() as _InheritedProviderScopeElement?; return inheritedElement; } } 3. ListenableProvider ChangeNotifierProvider继承自ListenableProvider。先看ListenableProvider class ListenableProvider extends InheritedProvider { ListenableProvider({ Key? key, required Create create, Dispose? dispose, bool? lazy, TransitionBuilder? builder, Widget? child, }) : super( key: key, startListening: _startListening, create: create, dispose: dispose, lazy: lazy, builder: builder, child: child, ); //实现了startListening。 static VoidCallback _startListening( InheritedContext e, Listenable? value, ) { //因为泛型约束 //所以value添加监听。方法是 markNeedsNotifyDependents。实现如下 value?.addListener(e.markNeedsNotifyDependents); //dispose的时候，移除监听 return () => value?.removeListener(e.markNeedsNotifyDependents); } } class _InheritedProviderScopeElement extends InheritedElement implements InheritedContext { @override //markNeedsNotifyDependents实现。其实就是调用 markNeedsBuild 执行刷新 void markNeedsNotifyDependents() { if (!_isNotifyDependentsEnabled) { return; } markNeedsBuild(); _shouldNotifyDependents = true; } } 4. ChangeNotifierProvider ChangeNotifierProvider只是修改了ListenableProvider的_dispose方法。 class ChangeNotifierProvider extends ListenableProvider { ChangeNotifierProvider({ Key? key, required Create create, bool? lazy, TransitionBuilder? builder, Widget? child, }) : super( key: key, create: create, dispose: _dispose, lazy: lazy, builder: builder, child: child, ); //执行ChangeNotifier 的 dispose static void _dispose(BuildContext context, ChangeNotifier? notifier) { notifier?.dispose(); } } "}}