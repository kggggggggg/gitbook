{"./":{"url":"./","title":"简介","keywords":"","body":"gitbook "},"algorithm/sorting.html":{"url":"algorithm/sorting.html","title":"排序算法","keywords":"","body":"🙉 排序算法(Sorting Algorithm) 冒泡排序(Bubble Sort) 选择排序(Selection Sort) 插入排序(Insertion Sort) 归并排序(Merge Sort) 快速排序(Quick Sort) 堆排序(Heap Sort) 桶排序(Bucket sort) 计数排序(Counting Sort) 基数排序(Radix Sort) 排序算法大全 "},"algorithm/sorting/bubble_sort.html":{"url":"algorithm/sorting/bubble_sort.html","title":"冒泡排序","keywords":"","body":"冒泡排序（Bubble Sort） 原地排序、稳定 void bubbleSort(int a[], int n) { for(int i = n - 1; i > 0; i--) for(int j = 0; j a[j+1]) swap(a[j], a[j+1]); } "},"algorithm/sorting/selection_sort.html":{"url":"algorithm/sorting/selection_sort.html","title":"选择排序","keywords":"","body":"选择排序（Selection Sort） 原地排序、不稳定 void selectionSort(int a[], int n) { for (int i = 0; i a[j]) { swap(a[i], a[j]); } } } } 通俗易懂讲解 选择排序.html void selectSort(int a[], int n) { for (int i = 0; i "},"algorithm/sorting/insertion_sort.html":{"url":"algorithm/sorting/insertion_sort.html","title":"插入排序","keywords":"","body":"插入排序（Insertion Sort） 原地排序、稳定 c++插入排序算法.html void InsertSort(int a[], int n) { for (int i = 1; i = 0 && a[j] > v) { a[j+1] = a[j]; j--; } a[j+1] = v; } } void insertionSort(int a[], int n) { if (n = 0; --j) { if (a[j] > value) { a[j+1] = a[j]; } else { break; } } a[j+1] = value; // 插入数据 } } "},"algorithm/sorting/merge_sort.html":{"url":"algorithm/sorting/merge_sort.html","title":"归并排序","keywords":"","body":"归并排序（Merge Sort） 不是原地排序算法、稳定(主要看merge函数) void merge(int a[],int l,int r,int mid) { int tmp[r-l+1]; int i = l, j = mid+1, k = 0; while (i =r) return; int mid=(l+r)/2; merge_sort(a,l,mid); merge_sort(a,mid+1,r); merge(a,l,r,mid); } void mergesort(int a[],int l,int r) { merge_sort(a,l,r-1); } merge算法使用哨兵优化 void merge(int a[],int l,int r,int mid) { int left[mid-l+2]; //左侧长度是midl-l+1 再加一个哨兵 int right[r-mid+1];//右侧长度是r-(mid+1)+1 再加一个哨兵 left[mid-l+1] = INT_MAX; right[r-mid] = INT_MAX; for (int i = l,k = 0; i "},"algorithm/sorting/quick_sort.html":{"url":"algorithm/sorting/quick_sort.html","title":"快速排序","keywords":"","body":"快速排序算法（Quicksort） 原地排序、不稳定 方式一 因为固定pivot是取得左边的值，所以while时，要先从右边找； void quickSort(int a[], int head, int tail) { int low = head; int high = tail; int pivot = a[low]; while (low= a[low]) low++; a[high]=a[low]; } a[low] = pivot; if(low>head+1) quickSort(a,head,low-1); if(high 方式二 1、因为先从右边找。 2、而最终因为low == high。 3、所以现在low和high的值小于a[head]。 4、判断条件 a[head] >= a[low] 导致a[head]位置不会变 也就是分割点位置不变，始终在head位置 5、所以最后需要再进行一次交换 swap(a[low], a[head]); void quickSort(vector& a, int head, int tail) { if (head >= tail) { return; } int low = head; int high = tail; while (low= a[low]) low++; swap(a[low], a[high]); } swap(a[low], a[head]); quickSort(a,head,low-1); quickSort(a,high+1,tail); } 方法三 int Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low = pivot) { --high; } A[low] = A[high]; while (low "}}