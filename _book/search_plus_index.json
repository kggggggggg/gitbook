{"./":{"url":"./","title":"ç®€ä»‹","keywords":"","body":"gitbook "},"algorithm/sorting.html":{"url":"algorithm/sorting.html","title":"æŽ’åºç®—æ³•","keywords":"","body":"ðŸ™‰ æŽ’åºç®—æ³•(Sorting Algorithm) å†’æ³¡æŽ’åº(Bubble Sort) é€‰æ‹©æŽ’åº(Selection Sort) æ’å…¥æŽ’åº(Insertion Sort) å½’å¹¶æŽ’åº(Merge Sort) å¿«é€ŸæŽ’åº(Quick Sort) å †æŽ’åº(Heap Sort) æ¡¶æŽ’åº(Bucket sort) è®¡æ•°æŽ’åº(Counting Sort) åŸºæ•°æŽ’åº(Radix Sort) æŽ’åºç®—æ³•å¤§å…¨ "},"algorithm/sorting/bubble_sort.html":{"url":"algorithm/sorting/bubble_sort.html","title":"å†’æ³¡æŽ’åº","keywords":"","body":"å†’æ³¡æŽ’åºï¼ˆBubble Sortï¼‰ åŽŸåœ°æŽ’åºã€ç¨³å®š void bubbleSort(int a[], int n) { for(int i = n - 1; i > 0; i--) for(int j = 0; j a[j+1]) swap(a[j], a[j+1]); } "},"algorithm/sorting/selection_sort.html":{"url":"algorithm/sorting/selection_sort.html","title":"é€‰æ‹©æŽ’åº","keywords":"","body":"é€‰æ‹©æŽ’åºï¼ˆSelection Sortï¼‰ åŽŸåœ°æŽ’åºã€ä¸ç¨³å®š void selectionSort(int a[], int n) { for (int i = 0; i a[j]) { swap(a[i], a[j]); } } } } é€šä¿—æ˜“æ‡‚è®²è§£ é€‰æ‹©æŽ’åº.html void selectSort(int a[], int n) { for (int i = 0; i "},"algorithm/sorting/insertion_sort.html":{"url":"algorithm/sorting/insertion_sort.html","title":"æ’å…¥æŽ’åº","keywords":"","body":"æ’å…¥æŽ’åºï¼ˆInsertion Sortï¼‰ åŽŸåœ°æŽ’åºã€ç¨³å®š c++æ’å…¥æŽ’åºç®—æ³•.html void InsertSort(int a[], int n) { for (int i = 1; i = 0 && a[j] > v) { a[j+1] = a[j]; j--; } a[j+1] = v; } } void insertionSort(int a[], int n) { if (n = 0; --j) { if (a[j] > value) { a[j+1] = a[j]; } else { break; } } a[j+1] = value; // æ’å…¥æ•°æ® } } "},"algorithm/sorting/merge_sort.html":{"url":"algorithm/sorting/merge_sort.html","title":"å½’å¹¶æŽ’åº","keywords":"","body":"å½’å¹¶æŽ’åºï¼ˆMerge Sortï¼‰ ä¸æ˜¯åŽŸåœ°æŽ’åºç®—æ³•ã€ç¨³å®š(ä¸»è¦çœ‹mergeå‡½æ•°) void merge(int a[],int l,int r,int mid) { int tmp[r-l+1]; int i = l, j = mid+1, k = 0; while (i =r) return; int mid=(l+r)/2; merge_sort(a,l,mid); merge_sort(a,mid+1,r); merge(a,l,r,mid); } void mergesort(int a[],int l,int r) { merge_sort(a,l,r-1); } mergeç®—æ³•ä½¿ç”¨å“¨å…µä¼˜åŒ– void merge(int a[],int l,int r,int mid) { int left[mid-l+2]; //å·¦ä¾§é•¿åº¦æ˜¯midl-l+1 å†åŠ ä¸€ä¸ªå“¨å…µ int right[r-mid+1];//å³ä¾§é•¿åº¦æ˜¯r-(mid+1)+1 å†åŠ ä¸€ä¸ªå“¨å…µ left[mid-l+1] = INT_MAX; right[r-mid] = INT_MAX; for (int i = l,k = 0; i "},"algorithm/sorting/quick_sort.html":{"url":"algorithm/sorting/quick_sort.html","title":"å¿«é€ŸæŽ’åº","keywords":"","body":"å¿«é€ŸæŽ’åºç®—æ³•ï¼ˆQuicksortï¼‰ åŽŸåœ°æŽ’åºã€ä¸ç¨³å®š æ–¹å¼ä¸€ å› ä¸ºå›ºå®špivotæ˜¯å–å¾—å·¦è¾¹çš„å€¼ï¼Œæ‰€ä»¥whileæ—¶ï¼Œè¦å…ˆä»Žå³è¾¹æ‰¾ï¼› void quickSort(int a[], int head, int tail) { int low = head; int high = tail; int pivot = a[low]; while (low= a[low]) low++; a[high]=a[low]; } a[low] = pivot; if(low>head+1) quickSort(a,head,low-1); if(high æ–¹å¼äºŒ 1ã€å› ä¸ºå…ˆä»Žå³è¾¹æ‰¾ã€‚ 2ã€è€Œæœ€ç»ˆå› ä¸ºlow == highã€‚ 3ã€æ‰€ä»¥çŽ°åœ¨lowå’Œhighçš„å€¼å°äºŽa[head]ã€‚ 4ã€åˆ¤æ–­æ¡ä»¶ a[head] >= a[low] å¯¼è‡´a[head]ä½ç½®ä¸ä¼šå˜ ä¹Ÿå°±æ˜¯åˆ†å‰²ç‚¹ä½ç½®ä¸å˜ï¼Œå§‹ç»ˆåœ¨headä½ç½® 5ã€æ‰€ä»¥æœ€åŽéœ€è¦å†è¿›è¡Œä¸€æ¬¡äº¤æ¢ swap(a[low], a[head]); void quickSort(vector& a, int head, int tail) { if (head >= tail) { return; } int low = head; int high = tail; while (low= a[low]) low++; swap(a[low], a[high]); } swap(a[low], a[head]); quickSort(a,head,low-1); quickSort(a,high+1,tail); } æ–¹æ³•ä¸‰ int Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low = pivot) { --high; } A[low] = A[high]; while (low "}}