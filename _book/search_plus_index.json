{"./":{"url":"./","title":"简介","keywords":"","body":"gitbook "},"algorithm/sorting.html":{"url":"algorithm/sorting.html","title":"排序算法","keywords":"","body":"🙉 排序算法(Sorting Algorithm) 冒泡排序(Bubble Sort) 选择排序(Selection Sort) 插入排序(Insertion Sort) 归并排序(Merge Sort) 快速排序(Quick Sort) 堆排序(Heap Sort) 桶排序(Bucket sort) 计数排序(Counting Sort) 基数排序(Radix Sort) 排序算法大全 "},"algorithm/sorting/bubble_sort.html":{"url":"algorithm/sorting/bubble_sort.html","title":"冒泡排序","keywords":"","body":"冒泡排序（Bubble Sort） 原地排序、稳定 void bubbleSort(int a[], int n) { for(int i = n - 1; i > 0; i--) for(int j = 0; j a[j+1]) swap(a[j], a[j+1]); } "},"algorithm/sorting/selection_sort.html":{"url":"algorithm/sorting/selection_sort.html","title":"选择排序","keywords":"","body":"选择排序（Selection Sort） 原地排序、不稳定 void selectionSort(int a[], int n) { for (int i = 0; i a[j]) { swap(a[i], a[j]); } } } } 通俗易懂讲解 选择排序.html void selectSort(int a[], int n) { for (int i = 0; i "},"algorithm/sorting/insertion_sort.html":{"url":"algorithm/sorting/insertion_sort.html","title":"插入排序","keywords":"","body":"插入排序（Insertion Sort） 原地排序、稳定 c++插入排序算法.html void InsertSort(int a[], int n) { for (int i = 1; i = 0 && a[j] > v) { a[j+1] = a[j]; j--; } a[j+1] = v; } } void insertionSort(int a[], int n) { if (n = 0; --j) { if (a[j] > value) { a[j+1] = a[j]; } else { break; } } a[j+1] = value; // 插入数据 } } "},"algorithm/sorting/merge_sort.html":{"url":"algorithm/sorting/merge_sort.html","title":"归并排序","keywords":"","body":"归并排序（Merge Sort） 不是原地排序算法、稳定(主要看merge函数) void merge(int a[],int l,int r,int mid) { int tmp[r-l+1]; int i = l, j = mid+1, k = 0; while (i =r) return; int mid=(l+r)/2; merge_sort(a,l,mid); merge_sort(a,mid+1,r); merge(a,l,r,mid); } void mergesort(int a[],int l,int r) { merge_sort(a,l,r-1); } merge算法使用哨兵优化 void merge(int a[],int l,int r,int mid) { int left[mid-l+2]; //左侧长度是midl-l+1 再加一个哨兵 int right[r-mid+1];//右侧长度是r-(mid+1)+1 再加一个哨兵 left[mid-l+1] = INT_MAX; right[r-mid] = INT_MAX; for (int i = l,k = 0; i "},"algorithm/sorting/quick_sort.html":{"url":"algorithm/sorting/quick_sort.html","title":"快速排序","keywords":"","body":"快速排序算法（Quicksort） 原地排序、不稳定 方式一 因为固定pivot是取得左边的值，所以while时，要先从右边找； void quickSort(int a[], int head, int tail) { int low = head; int high = tail; int pivot = a[low]; while (low= a[low]) low++; a[high]=a[low]; } a[low] = pivot; if(low>head+1) quickSort(a,head,low-1); if(high 方式二 1、因为先从右边找。 2、而最终因为low == high。 3、所以现在low和high的值小于a[head]。 4、判断条件 a[head] >= a[low] 导致a[head]位置不会变 也就是分割点位置不变，始终在head位置 5、所以最后需要再进行一次交换 swap(a[low], a[head]); void quickSort(vector& a, int head, int tail) { if (head >= tail) { return; } int low = head; int high = tail; while (low= a[low]) low++; swap(a[low], a[high]); } swap(a[low], a[head]); quickSort(a,head,low-1); quickSort(a,high+1,tail); } 方法三 int Paritition1(int A[], int low, int high) { int pivot = A[low]; while (low = pivot) { --high; } A[low] = A[high]; while (low "},"flutter/状态管理/InheritedWidget.html":{"url":"flutter/状态管理/InheritedWidget.html","title":"InheritedWidget","keywords":"","body":"【老孟Flutter】源码分析系列之InheritedWidget 一文搞懂InheritedWidget局部刷新机制 flutter防止widget rebuild终极解决办法 重写了updated方法，调用InheritedWidget的setStatus时，不会对所有子widget调用build。而是对注册的监听调用。 class InheritedElement extends ProxyElement{ @override void updated(InheritedWidget oldWidget) { if ((widget as InheritedWidget).updateShouldNotify(oldWidget)) { super.updated(oldWidget); --会调用notifyClients } } @override void notifyClients(InheritedWidget oldWidget) { assert(_debugCheckOwnerBuildTargetExists('notifyClients')); for (final Element dependent in _dependents.keys) { assert(() { // check that it really is our descendant Element? ancestor = dependent._parent; while (ancestor != this && ancestor != null) { ancestor = ancestor._parent; } return ancestor == this; }()); // check that it really depends on us assert(dependent._dependencies!.contains(this)); notifyDependent(oldWidget, dependent); //遍历每一个监听者，调用其notifyDependent } } } abstract class Element extends DiagnosticableTree implements BuildContext { @protected void notifyDependent(covariant InheritedWidget oldWidget, Element dependent) { dependent.didChangeDependencies(); } @mustCallSuper void didChangeDependencies() { assert(_lifecycleState == _ElementLifecycle.active); // otherwise markNeedsBuild is a no-op assert(_debugCheckOwnerBuildTargetExists('didChangeDependencies')); markNeedsBuild(); } void markNeedsBuild() { if (dirty) { return; } _dirty = true; owner!.scheduleBuildFor(this); } } class BuildOwner { void scheduleBuildFor(Element element) { _dirtyElements.add(element); //添加到dirtyElements列表中。 element._inDirtyList = true; } } 每一个InheritedElement都会被存储到_inheritedWidgets字典中。 abstract class BuildContext { InheritedElement? getElementForInheritedWidgetOfExactType(); //抽象类声明 } abstract class Element extends DiagnosticableTree implements BuildContext { PersistentHashMap? _inheritedWidgets; //每个Element都有这个 @mustCallSuper void mount(Element? parent, Object? newSlot) { //mount和activate方法会调用_updateInheritance _updateInheritance(); } @mustCallSuper void activate() { ... _updateInheritance(); } void _updateInheritance() { _inheritedWidgets = _parent?._inheritedWidgets; } @override InheritedElement? getElementForInheritedWidgetOfExactType() { final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; return ancestor; } } class InheritedElement extends ProxyElement{ @override void _updateInheritance() { final PersistentHashMap incomingWidgets = _parent?._inheritedWidgets ?? const PersistentHashMap.empty(); _inheritedWidgets = incomingWidgets.put(widget.runtimeType, this); //从父widget获取，并将自己保存起来。Widget的类型为key。element为value。 } } abstract class Element extends DiagnosticableTree implements BuildContext @override T? dependOnInheritedWidgetOfExactType({Object? aspect}) { assert(_debugCheckStateIsActiveForAncestorLookup()); final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T]; if (ancestor != null) { return dependOnInheritedElement(ancestor, aspect: aspect) as T; } _hadUnsatisfiedDependencies = true; return null; } @override InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) { //ancestor是 InheritedElement _dependencies ??= HashSet(); _dependencies!.add(ancestor); //存储当前element依赖了哪些InheritedElement ancestor.updateDependencies(this, aspect); //添加到InheritedElement中。 return ancestor.widget as InheritedWidget; } } class InheritedElement extends ProxyElement{ final Map _dependents = HashMap(); @protected void updateDependencies(Element dependent, Object? aspect) { setDependencies(dependent, null); } @protected void setDependencies(Element dependent, Object? value) { _dependents[dependent] = value; //添加到对应的map种。 这里value为空。 } } 本身所有的Element都维护一个map。（可以认为是一个全局的，因为会先从_parent获取） PersistentHashMap? _inheritedWidgets; element类型为key。 每一个InheritedElement实例对象都会维护一个map。 final Map _dependents = HashMap(); 以调用者的element为key，value可以为空。 当创建一个InheritedElement，调用mount时就会加入到_inheritedWidgets中。 查找的时候通过类型直接在map中找出。 调用dependOnInheritedWidgetOfExactType获取值的时候 _inheritedWidgets中找到对应的InheritedElement 将当前对象存储到InheritedElement对应的_dependents字典中 返回对应的InheritedElement 需要更新，调用InheritedWidget的update的时候 _dependents.keys获取存储的element，并调用其didChangeDependencies方法。 didChangeDependencies --> markNeedsBuild --> _dirty = true; 也就是说，InheritedElement重新创建，执行build的时候，只是将注册在自己_dependents字典的element进行了更新。 应该在didChangeDependencies()中做什么？ 一般来说，子 widget 很少会重写此方法，因为在依赖改变后 Flutter 框架也都会调用build()方法重新构建组件树。但是，如果你需要在依赖改变后执行一些昂贵的操作，比如网络请求，这时最好的方式就是在此方法中执行，这样可以避免每次build()都执行这些昂贵操作。 "}}